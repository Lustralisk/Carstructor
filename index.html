<!DOCTYPE html>
<html>
<head>
	<title>Carstructor</title>
	<script type="text/javascript" src="js/decomp.js"></script>
	<script type="text/javascript" src="js/matter.js"></script>
	<script type="text/javascript" src="js/angular.min.js"></script>
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/stylesheet.css" />
	<script type="text/javascript" src="js/jquery-3.0.0.min.js"></script>

	<script type="text/javascript">

	// 'welcome page section'
	// this section contains 'help' and 'start'
	var begin_scene = function() {

		$('#canvas').addClass('beginner');

		// logo div
		$("<div class='logo'><img src='./img/logo.png' style='width:100%;height:100%;' /></div>").appendTo($('#canvas'));

		// start game div, going to 'build section'
		$("<div class='button'><span>Start<span></div>").appendTo($('#canvas')).css({
			'left': '490px',
			'top': '350px',
			'width': '300px',
			'height': '130px',
		}).click(function() {
			$('#canvas').removeClass('beginner').children().remove();
			start_build();
		});

		// 'prompting helper div'
		// can move to 'prev' or 'next' page by clicking correlated buttons
		$("<div class='button'><span>Help</span></div>").appendTo($('#canvas')).css({
			'left': '490px',
			'top': '480px',
			'width': '300px',
			'height': '130px',
		}).click(function() {
			$("<div class='helper'><div id='closeHelper' class='close'></div><div class='prev'></div><div class='next'></div><div class='helperContent'></div></div>").appendTo($('#canvas')).animate({'top': '40px'}, 300).data('page', 0);
			$('#closeHelper').click(function() {
				$(".helper").animate({'top': '1040px'}, 300);
			});
			// next & prev button
			$('.next').click(function() {
				$('.helper').data('page', $('.helper').data('page') + 1);
				// if last page, hide 'next' button
				if ($('.helper').data('page') == 5) {
					$(this).css({'display': 'none'});
				}
				$('.prev').css({'display': 'block'});
				$('.helperContent').css({'background-image': 'url(./img/help' + ($('.helper').data('page') + 1) + '.png)'});
			});
			$('.prev').click(function() {
				$('.helper').data('page', $('.helper').data('page') - 1);
				// if first page, hide 'prev' button
				if ($('.helper').data('page') == 0) {
					$(this).css({'display': 'none'});
				}
				$('.next').css({'display': 'block'});
				$('.helperContent').css({'background-image': 'url(./img/help' + ($('.helper').data('page') + 1) + '.png)'});
			});
		});
	}

	// 'building section'
	// in this section, you can build your car in given coordinate
	// then pass to 'engine section'
	var start_build = function() {
		// initially focus the viewport to the car
		$('#focusView').prop('checked', true);
		$('#canvas').addClass('construct');

		// dargConfig is the connectional object between coordinate and tool box
		var dragConfig = null;
		for (var i = 0; i < 5; i++) {
			(function(i) {
				$('#obj' + (i + 1)).appendTo($('#canvas')).css({
					"left": "900px",
					"top": i * 80 + 50 + "px",
				}).mousedown(function() {
					if (dragConfig == null || dragConfig.obj != (i + 1)) {
						dragConfig = {
							"x": 900,
							"y": i * 80 + 50,
							"img": $(this).find("img")[0].src,
							"obj": i + 1,
						}
						$('.objs').css('background-color', '#555');
						$(this).css('background-color', '#999');
					}
					else {
						dragConfig = null;
						$(this).css('background-color', '#555');
					}
			})})(i);
		}
		// button for rotate the tool box clockwised
		$('#obj6').appendTo($('#canvas')).css({
			"left": "900px",
			"top": 5 * 80 + 50 + "px",
		}).data('rotate', 0).mousedown(function() {
			$(this).css('background-color', '#999');
		}).mouseup(function() {
			$(this).css('background-color', '#555');
			$(this).data('rotate', ($(this).data('rotate') + 1) % 4);
			$('.objs').not(this).not($('#obj7')).css({
	            '-webkit-transform':'rotate(' + $(this).data('rotate') * 90 + 'deg)', 
	            '-moz-transform':'rotate(' + $(this).data('rotate') * 90 + 'deg)',
	            'transform':'rotate(' + $(this).data('rotate') * 90 + 'deg)'
	        });
		});
		// cancel button
		$('#obj7').appendTo($('#canvas')).css({
			"left": "900px",
			"top": 6 * 80 + 50 + "px",
		}).data('rotate', 0).mousedown(function() {
			$(this).css('background-color', '#999');
		}).mouseup(function() {
			$('.objs').css('background-color', '#555');
			$(this).css('background-color', '#999');
			if (dragConfig != null && dragConfig.obj == -1) {
				dragConfig = null;
			}
			else {
				dragConfig = {
					'obj': -1,
				};
			}
		});
		// create coordinate
		// 10 x 12 box, each unit can set with less than one tool
		var blocks = [];
		for (var i = 0; i < 10; i++) {
			blocks.push([]);
			for (var j = 0; j < 12; j++) {
				blocks[i].push($("<div class='unit'></div>").data('used', false).data('obj', 0).data('rotate', 0).appendTo($('#canvas')).css({
					"left": 80 + 60 * j + "px",
					"top": 60 + 60 * i + "px",
				}).mouseenter(function() {
					if (dragConfig != null && $(this).data('used') == false && dragConfig.obj != -1) {
						if ($(this).find('img').length == 0) {
							$(this).append($("<img style='opacity:0.4;' src=" + dragConfig.img + " />")).css({
					            '-webkit-transform':'rotate(' + $('#obj6').data('rotate') * 90 + 'deg)', 
					            '-moz-transform':'rotate(' + $('#obj6').data('rotate') * 90 + 'deg)',
					            'transform':'rotate(' + $('#obj6').data('rotate') * 90 + 'deg)'
					        });
						}
					}
				}).mouseleave(function() {
					if ($(this).data('used') == false) {
						$(this).children().remove();
					}
				}).mousedown(function() {
					if (dragConfig != null && dragConfig.obj != -1) {
						if ($(this).data('used') == false) {
							$(this).children().remove();
							$(this).append($("<img src=" + dragConfig.img + " />")).data('used', true).data('obj', dragConfig.obj).data('rotate', $('#obj6').data('rotate'));
						}
						// uncommment next line will enable one tool box each placement
						// dragConfig = null;
					}
					else
					if (dragConfig != null && dragConfig.obj == -1) {
						if ($(this).data('used') == true) {
							$(this).children().remove();
							$(this).data('used', false).data('obj', 0);
						}
					}
				}));
			}
		}
		// this is the first certain box that already placed on the board
		blocks[4][5].data('used', true).data('obj', 1).append($("<img src='img/wood.pdf' />"))
		$('<div id="start_engine" class="button"><span>Go<span></div>').appendTo("#canvas").css({
			'left': '860px',
			'top': '600px',
			'width': '160px',
			'height': '100px',
		}).click(function() {
			// message that passed to the 'start engine'
			var setting = [];
			for (var i = 0; i < 10; i++) {
				setting.push([]);
				for (var j = 0; j < 10; j++) {
					setting[i].push({
						type: blocks[i][j].data('obj'),
						dir: blocks[i][j].data('rotate'),
					})
				}
			}

			// design animation passing through
			$('.objs').animate({'left': '1400px'}, 500);
			$('.unit').animate({'left': '-100px'}, 500);
			$('#start_engine').animate({'left': '1400px'}, 500);
			$('.controller').animate({'left': '1050px'});
			setTimeout(function() {
				$('#canvas').children().remove();
				$('#canvas').removeClass('construct');
				start_engine(setting);
			}, 500);

		});
	}

	var createSandbox = function() {
		var Body = Matter.Body,
			Bodies = Matter.Bodies,
			Vertices = Matter.Vertices,
			Composites = Matter.Composites,
			Constraint = Matter.Constraint;

		var sandbox = [];

		group = Body.nextGroup(true);


		ceiling = Bodies.rectangle(2500, 0, 5000, 10, {isStatic: true});
		ground = Bodies.rectangle(2500, 1010, 5000, 20, {isStatic: true});
		lwall = Bodies.rectangle(0, 1250, 10, 3000, {isStatic: true});
		rwall = Bodies.rectangle(5000, 1250, 10, 3000, {isStatic: true});

		sandbox.push(ceiling);
		sandbox.push(ground);
		sandbox.push(lwall);
		sandbox.push(rwall);

		sandbox.push(Bodies.rectangle(1000, 855, 500, 10, {isStatic: true, angle: -0.645}));
		sandbox.push(Bodies.rectangle(1350, 855, 300, 300, {isStatic: true}));
		sandbox.push(Bodies.rectangle(2150, 700, 500, 300, {isStatic: true}));
		sandbox.push(Bodies.rectangle(3350, 775, 500, 450, {isStatic: true}));
		sandbox.push(Bodies.rectangle(4000, 775, 917, 10, {isStatic: true, angle: 0.512}));

		v = Vertices.fromPath('0 0 0 300 20 300 20 100 100 100 100 0');
		sandbox.push(Bodies.fromVertices(4700, 800, v, {isStatic: true}));

        var bridge = Composites.stack(2400, 500, 12, 1, 7, 10, function(x, y) {
            return Bodies.rectangle(x, y, 50, 20);
        });
        Composites.chain(bridge, 0.5, 0, -0.5, 0, { stiffness: 0.9 });
        sandbox.push(bridge);
        
        
        sandbox.push(Constraint.create({ pointA: { x: 2400, y: 550 }, bodyB: bridge.bodies[0], pointB: { x: -25, y: 0 } }));
        sandbox.push(Constraint.create({ pointA: { x: 3100, y: 550 }, bodyB: bridge.bodies[11], pointB: { x: 25, y: 0 } }));

		return sandbox;
	}

	var start_engine = function(blueprint){

		var audio = new Audio();
		audio.src = "./aud/bgm.mp3";
		audio.setAttribute('loop', 'loop');
		audio.play();

		var Engine = Matter.Engine,
			Render = Matter.Render,
			World = Matter.World,
			Bounds = Matter.Bounds,
			Bodies = Matter.Bodies,
			Body = Matter.Body,
			Composites = Matter.Composites,
			Composite = Matter.Composite,
			Constraint = Matter.Constraint,
			MouseConstraint = Matter.MouseConstraint,
			Events = Matter.Events,
			Mouse = Matter.Mouse;

		var keyboardMap = {
			fanleft: 65,    // a
			fanright: 68,   // d
			fanup: 87,      // w
			fandown: 83,    // s

			balloon: 66,    // b

			rocketleft: 74,   // j
			rocketright: 76,  // l
			rocketup: 73,     // i
			rocketdown: 75,   // k

			wheelforward: 221,    // right arrow
			wheelbackward: 219,   // left arrow

			viewup: 40,
			viewleft: 37,
			viewdown: 38,
			viewright: 39,
		}


		var status = {
			fanleft: false,
			fanright: false,
			fanup: false,
			fandown: false,
			fancount: 0,
			fanspritecount: 0,

			balloon: true,

			rocketleft: 0,
			rocketright: 0,
			rocketup: 0,
			rocketdown: 0,

			wheelforward: false,
			wheelbackward: false,

			lockview: true,
		}

		// config
		var config = {
			VIEW_MOVE_SPEED_X: 0.01,
			VIEW_MOVE_SPEED_Y: 0.01,
			VIEW_ZOOM_SCALE_MAX: 5.0,
			VIEW_ZOOM_SCALE_MIN: 0.3,
			ROCKET_FORCE: 0.005,
			FAN_FORCE: 0.00005,
			ROCKET_LAUNCH_TIME: 5000,
			BALLOON_FORCE: 0.002,
			FAN_SPRITE_NUM: 3,
		}

		var container = document.getElementById('canvas');

		// create an enging for physics world
		var engine = Engine.create();

		// create a render for engine
		var render = Render.create({
			element: container,
			engine: engine,
			options: {
				width: 1280,
				height: 720,
			}
		});

		// used for zoom in/out
		var mouseConstraint = MouseConstraint.create(engine, {
       		element: render.canvas
    	});

		// device original position
		var bodyoffset = {x: 20, y: 600};

		// width for each block
		var blockWidth = 50;


		// iterate through blueprint
		blocks = [], balloons = [], fans = [], rockets = [], wheels = [];
		for (var i = 0; i < blueprint.length; i++) {
			if (!blueprint[i]) {continue;}
			for (var j = 0; j < blueprint[i].length; j++) {
				if (blueprint[i][j]) {
					switch(blueprint[i][j].type) {
					case 1:  // blocks
						blocks.push({x: (j + 0.5) * blockWidth, y: (i + 0.5) * blockWidth});
						break;
					case 2:  // fans 
						fans.push({x: (j + 0.5) * blockWidth, y: (i + 0.5) * blockWidth, dir: blueprint[i][j].dir});
						break;
					case 3:  // wheels 
						// to see if there's a block around the wheel
						if ((blueprint[i-1] && blueprint[i-1][j] && blueprint[i-1][j].type == 1) || 
							(blueprint[i+1] && blueprint[i+1][j] && blueprint[i+1][j].type == 1) ||
							(blueprint[i][j+1] && blueprint[i][j+1].type == 1) ||
							(blueprint[i][j-1] && blueprint[i][j-1].type == 1)) {off = false}
						else {off = true}
						wheels.push({x: (j + 0.5) * blockWidth, y: (i + 0.5) * blockWidth, off: off});
						break;
					case 4:  // balloons
						// decide anchor point for balloon
						if (blueprint[i+1] && blueprint[i+1][j] && blueprint[i+1][j].type == 1) {anchor = 1}
						else if (blueprint[i+2] && blueprint[i+2][j] && blueprint[i+2][j].type == 1) {anchor = 2}
						else {anchor = 0} // anchor == 0 means that this balloon is not on device
						balloons.push({x: (j + 0.5) * blockWidth, y: (i + 0.5) * blockWidth, anchor: anchor});
						break;
					case 5:  // rockets
						rockets.push({x: (j + 0.5) * blockWidth, y: (i + 0.5) * blockWidth, dir: blueprint[i][j].dir});
						break;
					default:
						break;
					}
				}
			}
		}

		// create device & offdevice
		var device = Composite.create({label: 'device'});
		var offdevice = Composite.create({label: 'offdevice'});

		// create blocks
		b = []
		for (var i = 0; i < blocks.length; i++) {
			var block = Bodies.rectangle(
				bodyoffset.x + blocks[i].x,
				bodyoffset.y + blocks[i].y,
				blockWidth,
				blockWidth,
				{
					collisionFilter: {
						group: -1,
					},
					label: "block",
					density: 0.001,
					frictionAir: 0,
					render: {
						sprite: {
					 		xScale: 0.11,
							yScale: 0.11,
							texture: './img/wood.pdf',
						}
					}
				});
			b.push(block);
		}
		body = Body.create({parts: b, collisionFilter: {group: -1,},density: 0.01,});
		Composite.add(device, body);

		// create wheels
		w = [];
		for (var i = 0; i < wheels.length; i++) {
			var wheel = Bodies.circle(
				bodyoffset.x + wheels[i].x,
				bodyoffset.y + wheels[i].y,
				0.46 * blockWidth,
				{
					collisionFilter: {
						group: -1,
					},
					friction: 1.0,
					staticFriction: 1.0,
					label: "wheel",
					density: 0.001,
					render: {
						sprite: {
							xScale: 0.11,
							yScale: 0.11,
							texture: './img/wheel.pdf',
						}
					}
				}
			)
			if (wheels[i].off == true) {Composite.add(offdevice, wheel)}
			else {Composite.add(device, wheel); w.push(wheel);}
		}
		for (var i = 0; i < w.length; i++) {
			Composite.add(device, Constraint.create({
				bodyA: body, 
				bodyB: w[i],
				pointA: {
					x: w[i].position.x - body.position.x,
					y: w[i].position.y - body.position.y,
				},
				stiffness: 0.1,
			}))
		}

		// create balloons
		b = [];
		bc = [];
		for (var i = 0; i < balloons.length; i++) {
			var balloon = Bodies.circle(
				bodyoffset.x + balloons[i].x,
				bodyoffset.y + balloons[i].y,
				0.4 * blockWidth,
				{
					collisionFilter: {
						group: -1,
					},
					label: "balloon",
					density: 0.001,
					frictionAir: 0.01,
					anchor: balloons[i].anchor,
					render: {
						sprite: {
							xScale: 0.11,
							yScale: 0.11,
							texture: './img/balloon.pdf',
						}
					}
				}
			)
			if (balloons[i].anchor == 0) {Composite.add(offdevice, balloon)}
			else {Composite.add(device,balloon)}
			b.push(balloon);
		}
		// Composite.add(device, b);
		for (var i = 0; i < b.length; i++) {
			if (b[i].anchor == 0) {continue;}
			c = Constraint.create({
				bodyA: body, 
				bodyB: b[i],
				pointA: {
					x: b[i].position.x - body.position.x,
					y: b[i].position.y - body.position.y + blockWidth * (b[i].anchor - 0.5),
				},
				pointB: {
					x: 0, y : 0.3 * blockWidth,
				},
				stiffness: 0.01,
			});
			Composite.add(device, c);
			bc.push(c);
		}

		// offsets for fan/rocket constraints
		offx1 = -0.2 * blockWidth, offx2 = 0.2 * blockWidth;

		// create fans
		f = [];
		for (var i = 0; i < fans.length; i++) {
			fan = Bodies.rectangle(
				bodyoffset.x + fans[i].x,
				bodyoffset.y + fans[i].y,
				0.9*blockWidth,0.9*blockWidth,
				{
					collisionFilter: {
						group: -1,
					},
					label: "fan",
					density: 0.00001,
					frictionAir: 0,
					dir: fans[i].dir,
					angle: Math.PI / 2 * fans[i].dir,
					render: {
						sprite: {
							xScale: 0.11,
							yScale: 0.11,
							texture: './img/screw_1.pdf',
						}
					}
				})
			f.push(fan);
		}
		Composite.add(device, f);
		for (var i = 0; i < f.length; i++) {
			Composite.add(device, Constraint.create({
				bodyA: body,
				bodyB: f[i],
				pointA: {
					x: f[i].position.x - body.position.x - offx1,
					y: f[i].position.y - body.position.y,
				},
				pointB: {
					x: - offx1,
					y: 0,
				},
				stiffness: 0.5
			}))
			Composite.add(device, Constraint.create({
				bodyA: body,
				bodyB: f[i],
				pointA: {
					x: f[i].position.x - body.position.x - offx2,
					y: f[i].position.y - body.position.y,
				},
				pointB: {
					x: - offx2,
					y: 0,
				},
				stiffness: 0.5
			}))
		}

		// create rockets
		r = [];
		for (var i = 0; i < rockets.length; i++) {
			rocket = Bodies.rectangle(
				bodyoffset.x + rockets[i].x,
				bodyoffset.y + rockets[i].y,
				0.8 * blockWidth, 0.8 * blockWidth,
				{
					collisionFilter: {
						group: -1,
					},
					label: "rocket",
					density: 0.001,
					frictionAir: 0,
					dir: rockets[i].dir,
					angle: Math.PI / 2 * rockets[i].dir,
					render: {
						sprite: {
							xScale: 0.11,
							yScale: 0.11,
							texture: './img/rocket_1.pdf',
						}
					}
				})
			r.push(rocket);
		}
		Composite.add(device, r);
		for (var i = 0; i < r.length; i++) {
			Composite.add(device, Constraint.create({
				bodyA: body,
				bodyB: r[i],
				pointA: {
					x: r[i].position.x - body.position.x - offx1,
					y: r[i].position.y - body.position.y,
				},
				pointB: {
					x: - offx1,
					y: 0,
				},
				stiffness: 0.5
			}))
			Composite.add(device, Constraint.create({
				bodyA: body,
				bodyB: r[i],
				pointA: {
					x: r[i].position.x - body.position.x - offx2,
					y: r[i].position.y - body.position.y,
				},
				pointB: {
					x: - offx2,
					y: 0,
				},
				stiffness: 0.5
			}))
		}

		// create a sandbox world
		sandbox = createSandbox();

		World.add(engine.world, sandbox);               // add sandbox to world
		World.add(engine.world, [device, offdevice]);   // add device and offdevice to world


        // get object's center position helper
        var get_position = function(obj) {
        	x = 0, y = 0;
            for (i = 0; i < obj.bodies.length; i++) {
            	x += obj.bodies[i].position.x;
            	y += obj.bodies[i].position.y;
            }
            return {x: x / obj.bodies.length, y: y / obj.bodies.length};
        }

        // view port setting
		var viewportCentre = {
            x: render.options.width * 0.5,
            y: render.options.height * 0.5
        };

        // keep track of current bounds scale (view zoom)
        var boundsScaleTarget = 1,
            boundsScale = {
                x: 1,
                y: 1
            };


        // watch 'beforeTick' event to update viewport
		Events.on(engine, 'beforeTick', function() {
            var world = engine.world,
                mouse = mouseConstraint.mouse,
                translate;

            // mouse wheel controls zoom
            var scaleFactor = mouse.wheelDelta * -0.1;
            if (scaleFactor !== 0) {
                if ((scaleFactor < 0 && boundsScale.x >= config.VIEW_ZOOM_SCALE_MIN) || 
                	(scaleFactor > 0 && boundsScale.x <= config.VIEW_ZOOM_SCALE_MAX)) {
                    boundsScaleTarget += scaleFactor;
                }
            }
            // if scale has changed
            if (Math.abs(boundsScale.x - boundsScaleTarget) > 0.01) {
                // smoothly tween scale factor
                scaleFactor = (boundsScaleTarget - boundsScale.x) * 0.2;
                boundsScale.x += scaleFactor;
                boundsScale.y += scaleFactor;
                // scale the render bounds
                render.bounds.max.x = render.bounds.min.x + render.options.width * boundsScale.x;
                render.bounds.max.y = render.bounds.min.y + render.options.height * boundsScale.y;
                // translate so zoom is from centre of view
                translate = {
                    x: render.options.width * scaleFactor * -0.5,
                    y: render.options.height * scaleFactor * -0.5,
                };
                Bounds.translate(render.bounds, translate);
                // update mouse
                Mouse.setScale(mouse, boundsScale);
                Mouse.setOffset(mouse, render.bounds.min);
            }



        });

		// keyboard events
		$('body').on('keydown', function (event) {
			event.preventDefault();
			// keysDown[event.keyCode] = true;

			if (event.keyCode == keyboardMap.wheelforward) {
				status.wheelforward = true;							// move foreward
			} else if (event.keyCode == keyboardMap.wheelbackward) {
				status.wheelbackward = true;						// move backward
			} else if (event.keyCode == keyboardMap.fanleft) {
				status.fanleft = !status.fanleft;					// ture on/off fan facing left
			} else if (event.keyCode == keyboardMap.fanright) {
				status.fanright = !status.fanright;					// ture on/off fan facing right
			} else if (event.keyCode == keyboardMap.fanup) {
				status.fanup = !status.fanup;						// ture on/off fan facing up
			} else if (event.keyCode == keyboardMap.fandown) {
				status.fandown = !status.fandown;					// ture on/off fan facing down
			} else if (event.keyCode == keyboardMap.rocketleft) {
				if (status.rocketleft == 0) {					// if the rockets haven't started yet
					status.rocketleft = 1;
					for (var i = 0; i < r.length; i++) {
						if (r[i].dir == 3) {
							r[i].render.sprite.texture = './img/rocket_2.pdf';
						}											// set texture for lit rockets
					}
					setTimeout(function() {							// set call back to 
						status.rocketleft = -1;						// 		set texture back
						for (var i = 0; i < r.length; i++) {
							if (r[i].dir == 3) {
								r[i].render.sprite.texture = './img/rocket_1.pdf';
							}
						}
					}, config.ROCKET_LAUNCH_TIME);
				}
			} else if (event.keyCode == keyboardMap.rocketright) {
				if (status.rocketright == 0) {
					status.rocketright = 1;
					for (var i = 0; i < r.length; i++) {
						if (r[i].dir == 1) {
							r[i].render.sprite.texture = './img/rocket_2.pdf';
						}
					}
					setTimeout(function() {
						status.rocketright = -1;
						for (var i = 0; i < r.length; i++) {
							if (r[i].dir == 1) {
								r[i].render.sprite.texture = './img/rocket_1.pdf';
							}
						}
					}, config.ROCKET_LAUNCH_TIME);
				}
			} else if (event.keyCode == keyboardMap.rocketup) {
				if (status.rocketup == 0) {
					status.rocketup = 1;
					for (var i = 0; i < r.length; i++) {
						if (r[i].dir == 0) {
							r[i].render.sprite.texture = './img/rocket_2.pdf';
						}
					}
					setTimeout(function() {
						status.rocketup = -1;
						for (var i = 0; i < r.length; i++) {
							if (r[i].dir == 0) {
								r[i].render.sprite.texture = './img/rocket_1.pdf';
							}
						}
					}, config.ROCKET_LAUNCH_TIME);
				}
			} else if (event.keyCode == keyboardMap.rocketdown) {
				if (status.rocketdown == 0) {
					status.rocketdown = 1;
					for (var i = 0; i < r.length; i++) {
						if (r[i].dir == 2) {
							r[i].render.sprite.texture = './img/rocket_2.pdf';
						}
					}
					setTimeout(function() {
						status.rocketdown = -1;
						for (var i = 0; i < r.length; i++) {
							if (r[i].dir == 2) {
								r[i].render.sprite.texture = './img/rocket_1.pdf';
							}
						}
					}, config.ROCKET_LAUNCH_TIME);
				}
			} else if (event.keyCode == keyboardMap.balloon) {
				if (status.balloon) {							// if ballons haven't been released
					status.balloon = false;
					Composite.remove(device, bc, true);			// remove constraint to let it go
					Composite.remove(device, b, true);			// remove balloon from device,
					Composite.add(offdevice, b);				// add balloon to offdevice,
																// so that viewport doesn't go wrong
				}
			}
			if (event.keyCode == keyboardMap.viewup) {			// viewport control
				status.viewup = true;
			} else if (event.keyCode == keyboardMap.viewdown) {
				status.viewdown = true;
			} else if (event.keyCode == keyboardMap.viewleft) {
				status.viewleft = true;
			} else if (event.keyCode == keyboardMap.viewright) {
				status.viewright = true;
			}

		});
		$('body').on('keyup', function (event) {
			event.preventDefault();
			if (event.keyCode == keyboardMap.wheelforward) {			// stop moving forward
				status.wheelforward = false;
			} else if (event.keyCode == keyboardMap.wheelbackward) {
				status.wheelbackward = false;							// stop moving backward
			}
			if (event.keyCode == keyboardMap.viewup) {
				status.viewup = false;									// stop moving viewport
			} else if (event.keyCode == keyboardMap.viewdown) {
				status.viewdown = false;
			} else if (event.keyCode == keyboardMap.viewleft) {
				status.viewleft = false;
			} else if (event.keyCode == keyboardMap.viewright) {
				status.viewright = false;
			}
		});
		$('#focusView').change(function() {								// focus on/off the device
			if (this.checked) {
				status.lockview = true;
			}
			else {
				status.lockview = false;
			}
		});
		Events.on(engine, 'tick', function() {

			// move wheels
			var maxspeed = 0.3;
			if (status.wheelforward == true) {
				for (var i = 0; i < w.length; i++) {
					Body.setAngularVelocity(w[i], w[i].angularVelocity < maxspeed ? (w[i].angularVelocity + 0.01) : maxspeed);
					// to let wheels have a max_speed and an angular acceleration.
				}
			} else if (status.wheelbackward == true){
				for (var i = 0; i < w.length; i++) {
					Body.setAngularVelocity(w[i], w[i].angularVelocity > -maxspeed ? (w[i].angularVelocity - 0.01) : -maxspeed);
				}
			}

			// adjust view port
			if (status.viewup == true) {
				Bounds.translate(render.bounds, {
					x: 0,
					y: render.options.height * config.VIEW_MOVE_SPEED_Y,
				});
				status.lockview = false;
				$('#focusView').prop('checked', false);
			}
			if (status.viewdown == true) {
				Bounds.translate(render.bounds, {
					x: 0,
					y: -render.options.height * config.VIEW_MOVE_SPEED_Y,
				});
				status.lockview = false;
				$('#focusView').prop('checked', false);
			}
			if (status.viewright == true) {
				Bounds.translate(render.bounds, {
					x: render.options.width * config.VIEW_MOVE_SPEED_X, 
					y: 0,
				});
				status.lockview = false;
				$('#focusView').prop('checked', false);
			}
			if (status.viewleft == true) {
				Bounds.translate(render.bounds, {
					x: -render.options.width * config.VIEW_MOVE_SPEED_X, 
					y: 0,
				});
				status.lockview = false;
				$('#focusView').prop('checked', false);
			}
			// focus view
			if (status.lockview == true) {
				Bounds.translate(render.bounds, {
					x: get_position(device).x - (render.bounds.min.x + render.bounds.max.x) / 2, 
					y: get_position(device).y - (render.bounds.min.y + render.bounds.max.y) / 2,
				});
			}

			// balloons
			// balloons always go up, and other part of this code will handle with connection with the device.
			for (var i = 0; i < b.length; i++) {
				Body.applyForce(b[i], b[i].position, {x: 0, y: -config.BALLOON_FORCE});
			}

			// rockets
			// compute the propulsion direction, see report for more detail.
			for (var i = 0; i < r.length; i++) {
				if ((r[i].dir == 0 && status.rocketup == 1) ||
					(r[i].dir == 1 && status.rocketright == 1) ||
					(r[i].dir == 2 && status.rocketdown == 1) ||
					(r[i].dir == 3 && status.rocketleft == 1)) {
					ang = r[i].angle;
					cos = Math.cos(ang);
					sin = Math.sin(ang);
					cos = cos < 0.17 ? 0 : cos;
					sin = sin < 0.17 ? 0 : sin;
					Body.applyForce(r[i], r[i].position, 
						{
							x: config.ROCKET_FORCE * sin, 
							y:  -config.ROCKET_FORCE * cos
						});
				}
			}

			// a simple status machine to control the fan texture(for fan animation)
			status.fancount = (status.fancount + 1) % 2
			if (status.fancount == 0) {status.fanspritecount = (status.fanspritecount + 1) % config.FAN_SPRITE_NUM}

			// fans
			// compute the propulsion direction for fans, see report for more detail.
			for (var i = 0; i < f.length; i++) {
				if ((f[i].dir == 0 && status.fanup == true) ||
					(f[i].dir == 1 && status.fanright == true) ||
					(f[i].dir == 2 && status.fandown == true) ||
					(f[i].dir == 3 && status.fanleft == true)) {
					ang = f[i].angle;
					cos = Math.cos(ang);
					sin = Math.sin(ang);
					cos = cos < 0.17 ? 0 : cos;
					sin = sin < 0.17 ? 0 : sin;
					Body.applyForce(f[i], f[i].position, 
						{
							x: config.FAN_FORCE * sin, 
							y:  -config.FAN_FORCE * cos
						});
					if (status.fancount == 0) {
						f[i].render.sprite.texture = './img/screw_' + (status.fanspritecount + 1) + '.pdf';
					}
				} 
			}
		})

		// run the physical world
		Engine.run(engine);

		// render options
		var renderOptions = render.options;
		renderOptions.hasBounds = true;
		renderOptions.wireframes = false;
		Render.run(render);
	};
	window.onload = begin_scene;
	</script>
</head>
<body>
	<div id="canvas">
	</div>
	<div class="controller" id="controller">
      	<div class="control-group">
        	<label for="focusView"> Focus Viewport </label>
        	<input id="focusView" type="checkbox" style="width:195px;" />
      	</div>
    </div>
    <div style="display:none;">
    	<div id="obj1" class="objs"><img src="img/wood.pdf" alt="wood" /></div>
    	<div id="obj2" class="objs"><img src="img/screw.pdf" alt="screw" /></div>
    	<div id="obj3" class="objs"><img src="img/wheel.pdf" alt="wheel" /></div>
    	<div id="obj4" class="objs"><img src="img/balloon.pdf" alt="balloon" /></div>
    	<div id="obj5" class="objs"><img src="img/rocket_1.pdf" alt="rocket" /></div>
    	<div id="obj6" class="objs"><img src="img/clockwise.pdf" alt="clockwise" /></div>
    	<div id="obj7" class="objs"><img src="img/cross.pdf" alt="cross" /></div>
    </div>
</body>
</html>